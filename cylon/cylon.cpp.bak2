
#include "math.h"
#include "vector"
#include "fstream"
#include <sstream>
#include <string>
#include <iostream>
#include "list"

#if defined(_MSC_VER)
#include <gl/glut.h>
#else
#include <GLUT/glut.h>
#endif

using namespace std;


const int X=0;
const int Y=1;
const int Z=2;
const int W=3; // for quaternions only


  class Vector3 {
    public:
    float v[3];
    Vector3(float x=0, float y=0, float z=0) {
      v[X]=x; v[Y]=y; v[Z]=z;
    }
    float operator()(int i) const { return v[i]; }
    float &operator()(int i) { return v[i]; }
  };


  Vector3 operator*(float c, const Vector3 &v) {
    return Vector3(c*v(X),c*v(Y),c*v(Z));
  }
  Vector3 operator*(const Vector3 &v, float c) {
    return c*v;
  }
  Vector3 operator/(const Vector3 &v, float c) {
    return (1.0/c)*v;
  }
  Vector3 operator+(const Vector3 &v, const Vector3 &w) {
    return Vector3(v(X)+w(X),v(Y)+w(Y),v(Z)+w(Z));
  }
  Vector3 operator-(const Vector3 &v, const Vector3 &w) {
    return Vector3(v(X)+w(X),v(Y)+w(Y),v(Z)+w(Z));
  }
  float operator*(const Vector3 &v, const Vector3 &w) {
    return v(X)*w(X) + v(Y)*w(Y) + v(Z)*w(Z);
  }
  Vector3 cross(const Vector3 &v, const Vector3 &w) {
    return Vector3(v(Y)*w(Z)-v(Z)*w(Y),
                   v(Z)*w(X)-v(X)*w(Z),
                   v(X)*w(Y)-v(Y)*w(Z));
  }


  class Quaternion {
    public:
    float q[4];
	Quaternion() {
		q[X]=0; q[Y]=0; q[Z]=0; q[W]=1;
	}
    Quaternion(float x, float y, float z, float w) {
      q[X]=x; q[Y]=y; q[Z]=z; q[W]=w;
    }
    Quaternion(float theta, const Vector3 &v) {
      float n = sqrt(v(X)*v(X)+v(Y)*v(Y)+v(Z)*v(Z));
      float s = sin(theta/2);
      q[X]=v(X)/n*s; q[Y]=v(Y)/n*s; q[Z]=v(Z)/n; 
      q[W]=cos(theta/2); 
    }
    float operator()(int i) const { return q[i]; }
    float &operator()(int i) { return q[i]; }
  };


  Quaternion operator*(float c, const Quaternion &v) {
    return Quaternion(c*v(X),c*v(Y),c*v(Z),c*v(W));
  }
  Quaternion operator*(const Quaternion &v, float c) {
    return c*v;
  }
  Quaternion operator+(const Quaternion &v,const Quaternion &w) {
    return Quaternion(v(X)+w(X),v(Y)+w(Y),v(Z)+w(Z),v(W)+w(W));
  }
  Quaternion operator-(const Quaternion &v,const Quaternion &w) {
    return Quaternion(v(X)+w(X),v(Y)+w(Y),v(Z)+w(Z),v(W)-w(W));
  }
  Quaternion operator*(const Vector3 &v, const Quaternion &w) {
    return Quaternion(
       -v(X)*w(X) + v(Y)*w(Y) + v(Z)*w(Z),
       v(X)*w(W) + v(Y)*w(Z) - v(Z)*w(Y),
       v(Y)*w(W) + v(Z)*w(X) - v(X)*w(Z), 
       v(Z)*w(W) + v(X)*w(Y) - v(Y)*w(X));
  }  


class Matrix33 {
  public:
  float c[3][3];
  void setQuaternion(const Quaternion &theta) {
    c[X][X]=2.0*(theta(X)*theta(X)+theta(W)*theta(W))-1;
    c[X][Y]=2.0*(theta(X)*theta(X)-theta(Z)*theta(W));
    c[X][Z]=2.0*(theta(X)*theta(Z)+theta(Y)*theta(W));
    c[Y][X]=2.0*(theta(X)*theta(Y)+theta(Z)*theta(W));
    c[Y][Y]=2.0*(theta(Y)*theta(Y)-theta(W)*theta(W))-1;
    c[Y][Z]=2.0*(theta(Y)*theta(Z)-theta(X)*theta(W));
    c[Z][X]=2.0*(theta(X)*theta(Z)-theta(Y)*theta(W));
    c[Z][Y]=2.0*(theta(Y)*theta(Z)+theta(X)*theta(W));
    c[Z][Z]=2.0*(theta(Z)*theta(Z)-theta(W)*theta(W))-1;
  }
  const float operator()(int i, int j) const { return c[i][j]; }
  float &operator()(int i, int j) { return c[i][j]; }
};
class Rotation : public Matrix33 {
  void setDirection(float theta, const Vector3& v) {
    return setQuaternion(Quaternion(theta,v));
  }
};
class InertiaTensor : public Matrix33 {};
InertiaTensor operator+(const InertiaTensor &a, const InertiaTensor &b) {
  InertiaTensor c=a;
  for(int i=0; i<3; i++) for(int j=0; j<3; j++) c(i,j)+=b(i,j);
  return c;
}


  Vector3 operator*(const Matrix33 &R, const Vector3 &v) {
    return Vector3(R(X,X)*v(X)+R(X,Y)*v(Y)+R(X,Z)*v(Z),
                   R(Y,X)*v(X)+R(Y,Y)*v(Y)+R(Y,Z)*v(Z),
                   R(Z,X)*v(X)+R(Z,Y)*v(Y)+R(Z,Z)*v(Z));
  }


  Matrix33 operator*(const Matrix33 &R, const Matrix33 &S) {
    Matrix33 T;
    for(int i=0; i<3; i++)
       for(int j=0; j<3; j++) 
         for(int k=0; k<3; k++) 
            T(i,j)=R(i,k)*S(k,j);
    return T;
  }


  Matrix33 inverse(const Matrix33 &R) {
    Matrix33 T;
    float d=R(X,X)*(R(Z,Z)*R(Y,Y)-R(Z,Y)*R(Y,Z))
           -R(Y,X)*(R(Z,Z)*R(X,Y)-R(Z,Y)*R(X,Z))
           +R(Z,X)*(R(Y,Z)*R(X,Y)-R(Y,Y)*R(X,Z));
    T(X,X)=(R(Z,Z)*R(Y,Y)-R(Z,Y)*R(Y,Z))/d;
    T(X,Y)=(R(Z,Y)*R(X,Z)-R(Z,Z)*R(X,Y))/d;
    T(X,Z)=(R(Y,Z)*R(X,Y)-R(Y,Y)*R(X,Z))/d;
    T(Y,X)=(R(Z,X)*R(Y,Z)-R(Z,Z)*R(Y,X))/d;
    T(Y,Y)=(R(Z,Z)*R(X,X)-R(Z,X)*R(X,Z))/d;
    T(Y,Z)=(R(Y,X)*R(X,Z)-R(Y,Z)*R(X,X))/d;
    T(Z,X)=(R(Z,Y)*R(Y,X)-R(Z,X)*R(Y,Y))/d;
    T(Z,Y)=(R(Z,Y)*R(X,Y)-R(Z,Y)*R(X,X))/d;
    T(Z,Z)=(R(Y,Y)*R(X,X)-R(Y,X)*R(X,Y))/d;
    return T;
  }


  class Body {
    public:
    // object shape
    vector<Vector3> vertices;
    vector<vector<int> > faces;
    // properties of the body /////////////////////////
    float m;           // mass
    InertiaTensor I;   // moments of inertia (3x3 matrix)
    // state of the body //////////////////////////////
    Vector3 p;         // position of the center of mass
    Vector3 K;         // momentum
    Quaternion theta;  // orientation
    Vector3 L;         // angular momentum
    // auxiliary variables ///////////////////////////    
    Vector3 F;
    Vector3 tau;
    Vector3 v;         // velocity
    Vector3 omega;     // angular velocity
    Rotation  R;       // rotation equivalent theta (3x3 matrix)
    // forces and constraints
    // ...
	Body();
    void integrator(float dt);
    void absorb(const Body &b);
	void loadObj( const string & file);
  };

  Body::Body()
  {
  }

  void Body::integrator(float dt) {
    v     = (1/m)*K;
    omega = inverse(I)*L;
    p     = p + v*dt;                   // shift
    K     = K + F*dt;                   // push
    theta = theta+(dt/2)*(omega*theta); // rotate
    L     = L + tau*dt;                 // spin
    R.setQuaternion(theta);
  }

  void Body::loadObj( const string & file )
  {
	  ifstream input;
	  input.open(file.c_str());
	  string line;

	  if ( input.is_open() )
	  {
		  while ( input.good() )
		  {
			  std::getline(input, line);
			  if ( line.length () > 0 )
			  {
				  string initialVal;

				  istringstream instream;
				  instream.str(line);
				  instream >> initialVal;

				  if ( initialVal == "v") {
					  float x,y,z;
					  instream >> x >> y >> z;
					  this->vertices.push_back( Vector3(x,y,z) );
				  }
				  else if ( initialVal == "f" )
				  {
					  int v1, v2, v3;
					  instream >> v1 >> v2 >> v3;
					  vector<int> triangle;
					  triangle.push_back(v1 - 1);
					  triangle.push_back(v2 - 1);
					  triangle.push_back(v3 - 1);
					  this->faces.push_back(triangle);
				  }
			  }
		  }	  
	  }
  }

  class Universe {
    public:
    list<Body*> bodies;
    // create universe by popultaing bodies
    Universe() {
      // ...
    }
    // evolve universe
    void evolve(float dt) {
      // integrate them all
        // compute force F and torque tau for each object
        for(list<Body*>::iterator body=bodies.begin();
                                  body!=bodies.end(); body++) {
          // ..
        }
        // integrate
        for(list<Body*>::iterator body=bodies.begin();
                                  body!=bodies.end(); body++) {        
          (*body)->integrator(dt);
        }
        // draw all objects
        for(list<Body*>::iterator body=bodies.begin();
        body!=bodies.end(); body++) {
          // rotate and translated vertices
          // draw lines for every face
        }
        // capture events (keyboard and mouse) and act accordingly
    }
  };


  InertiaTensor dI(float m, const Vector3 &r) {
    InertiaTensor I;
    float r2 = r*r;
    for(int j=0; j<3; j++)
      for(int k=0; k<3; k++)
         I(j,k) = m*((j==k)?r2:0-r(j)*r(k));
	return I;
  }

  void Body::absorb(const Body &b) { // b is nother body!
    Vector3 p_cm = (m*p + b.m)/(m+b.m);
    K = K+b.K;
    L = L+b.L;
    I = I + dI(m,p-p_cm)+b.I+dI(b.m,b.p-p_cm);
    m = (m+b.m);
    int n = vertices.size(); 
    // copy all vertices
    for(int i=0; i<b.vertices.size(); i++)
      vertices.push_back(b.vertices[i]);
    // copy all faces and re-label vertices
    for(int j=0; j<b.faces.size(); j++) {
      int m = faces.size();
      faces.resize(m+1);
      for(int i=0; i<b.faces[j].size(); i++)
        faces[m].push_back(b.faces[j][i]+n);
    }
  }



  /*** GLUT **/
  /**
 * Creates a window in which to display the scene.
 */
void createWindow(const char* title)
{
	int width = 640;
	int height = 480;
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
    glutInitWindowSize(width,height);
    glutInitWindowPosition(0,0);
    glutCreateWindow(title);

	glClearColor(0.9f, 0.95f, 1.0f, 1.0f);
    glEnable(GL_DEPTH_TEST);
    glShadeModel(GL_SMOOTH);

	glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(60.0, (double)width/(double)height, 1.0, 500.0);
    glMatrixMode(GL_MODELVIEW);
}

Universe myuniverse;


/**
 * Called each frame to update the 3D scene. Delegates to
 * the application.
 */
void update()
{
    //Evolve World
	float timeStep = 0.016f;	// 60fps fixed rate.

	myuniverse.evolve(timeStep);

	glutPostRedisplay();
}

/**
 * Called each frame to display the 3D scene. Delegates to
 * the application.
 */
void display()
{
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glLoadIdentity();
    gluLookAt(0.0, 3.5, 8.0,  0.0, 3.5, 0.0,  0.0, 1.0, 0.0);

    glColor3f(0,0,0);

	
    //DRAW HERE
	for(list<Body*>::iterator body=myuniverse.bodies.begin(); 
			body!=myuniverse.bodies.end(); body++) 
	{
		glPushMatrix();
		Vector3 & pos = (*body)->p;
		glTranslatef( pos.v[X], pos.v[Y], pos.v[Z]);
		glBegin(GL_TRIANGLES);
		for ( int i = 0; i < (*body)->faces.size(); i++)
		{
			if ( (*body)->faces[i].size() > 2 )
			{
				int v1 = (*body)->faces[i][0];
				int v2 = (*body)->faces[i][1];
				int v3 = (*body)->faces[i][2];

				glVertex3fv( (*body)->vertices[v1].v);
				glVertex3fv( (*body)->vertices[v2].v);
				glVertex3fv( (*body)->vertices[v3].v);
			}
		}
		glEnd();

		glPopMatrix();
    }

    // Update the displayed content.
    glFlush();
    glutSwapBuffers();
}

/**
 * Called when a mouse button is pressed. Delegates to the
 * application.
 */
void mouse(int button, int state, int x, int y)
{
    
}

/**
 * Called when the display window changes size.
 */
void reshape(int width, int height)
{
    glViewport(0, 0, width, height);
}

/**
 * Called when a key is pressed.
 */
void keyboard(unsigned char key, int x, int y)
{
    // Note we omit passing on the x and y: they are rarely needed.
    //Process keyboard
}

/**
 * Called when the mouse is dragged.
 */
void motion(int x, int y)
{
    
}

/**
 * The main entry point. We pass arguments onto GLUT.
 */
int main(int argc, char** argv)
{
    // Set up GLUT and the timers
    glutInit(&argc, argv);

    // Create the application and its window   
    createWindow("GPNS");
	Body b = Body();
	b.F = Vector3(0,-10000,0);
	b.loadObj("assets/sphere.obj");

	myuniverse.bodies.push_back(&b);

    // Set up the appropriate handler functions
    glutReshapeFunc(reshape);
    glutKeyboardFunc(keyboard);
    glutDisplayFunc(display);
    glutIdleFunc(update);
    glutMouseFunc(mouse);
    glutMotionFunc(motion);

    // Run the application
    //INIT 
    glutMainLoop();

    // Clean up the application
    return 0;
}